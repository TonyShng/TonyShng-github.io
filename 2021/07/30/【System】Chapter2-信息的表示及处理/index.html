<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.cat.net/css?family=Lato:300,300italic,400,400italic,700,700italic%7CLobster+Two:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CAria:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;raintwo.wang&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;livere&quot;,&quot;active&quot;:true,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;/search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}"><meta name="description" content="现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为位（bit），形成了数字革命的基础。二值信号能够很容易地被表示、存储和传输，例如可以表示为穿孔卡片上有洞或者无洞、导线上的高电压或者低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。"><meta property="og:type" content="article"><meta property="og:title" content="【System】Chapter2:信息的表示及处理"><meta property="og:url" content="https://raintwo.wang/2021/07/30/%E3%80%90System%E3%80%91Chapter2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%A4%84%E7%90%86/index.html"><meta property="og:site_name" content="TonyShng&#39;s Blog"><meta property="og:description" content="现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为位（bit），形成了数字革命的基础。二值信号能够很容易地被表示、存储和传输，例如可以表示为穿孔卡片上有洞或者无洞、导线上的高电压或者低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-07-30T00:05:15.000Z"><meta property="article:modified_time" content="2021-08-12T07:12:38.304Z"><meta property="article:author" content="TonyShng"><meta property="article:tag" content="System"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://raintwo.wang/2021/07/30/%E3%80%90System%E3%80%91Chapter2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%A4%84%E7%90%86/"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>【System】Chapter2:信息的表示及处理 | TonyShng's Blog</title><script data-pjax src="/js/load-config.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ed0ccaa898ed1b3d6654d777a61fe2cd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">TonyShng's Blog</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">努力，奋斗！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8"><span class="nav-number">1.</span> <span class="nav-text">2.1 信息存储</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">2.1.1 十六进制表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-%E5%AD%97%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.2.</span> <span class="nav-text">2.1.2 字数据大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">2.1.3 寻址和字节顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-4-%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.4.</span> <span class="nav-text">2.1.4 表示字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-%E8%A1%A8%E7%A4%BA%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.</span> <span class="nav-text">2.1.5 表示代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-6-%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="nav-number">1.6.</span> <span class="nav-text">2.1.6 布尔代数简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-7-C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BA%A7%E8%BF%90%E7%AE%97"><span class="nav-number">1.7.</span> <span class="nav-text">2.1.7 C语言中的位级运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-8-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">1.8.</span> <span class="nav-text">2.1.8 C 语言中的逻辑运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-9-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.9.</span> <span class="nav-text">2.1.9 C 语言中的移位运算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.</span> <span class="nav-text">2.2 整数表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">2.2.1 整型数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81"><span class="nav-number">2.2.</span> <span class="nav-text">2.2.2 无符号数的编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-%E8%A1%A5%E7%A0%81%E7%BC%96%E7%A0%81"><span class="nav-number">2.3.</span> <span class="nav-text">2.2.3 补码编码</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="TonyShng" src="/images/avatar.png"><p class="site-author-name" itemprop="name">TonyShng</p><div class="site-description" itemprop="description">no pain no gain!</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/TonyShng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TonyShng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:wangtony824@gmail.com" title="E-Mail → mailto:wangtony824@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">baidu</a></li><li class="links-of-blogroll-item"><a href="https://google.com/" title="https:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">google</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://raintwo.wang/2021/07/30/%E3%80%90System%E3%80%91Chapter2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%A4%84%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="TonyShng"><meta itemprop="description" content="no pain no gain!"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="TonyShng's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">【System】Chapter2:信息的表示及处理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-30 08:05:15" itemprop="dateCreated datePublished" datetime="2021-07-30T08:05:15+08:00">2021-07-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-08-12 15:12:38" itemprop="dateModified" datetime="2021-08-12T15:12:38+08:00">2021-08-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/System/" itemprop="url" rel="index"><span itemprop="name">System</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为<strong>位</strong>（bit），形成了数字革命的基础。二值信号能够很容易地被表示、存储和传输，例如可以表示为穿孔卡片上有洞或者无洞、导线上的高电压或者低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。</p><span id="more"></span><p>孤立的讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释（interpretation），即赋予不同的可能位模式以含义，我们就能够表示任何有限集合的元素。</p><p><strong>无符号</strong>（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。<strong>补码</strong>（two’s-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。浮点数（floating-point）编码是表示实数的科学计数法的以2为基数的版本。计算机用这些不同的表示方法实现算数运算。</p><p>计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会<strong>溢出</strong>（overflow）。溢出会导致某些令人吃惊的后果。另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律和交换律，计算下面任何一个C表达式，都会得出一致的结果。计算机可能没有产生期望的结果，但是至少它是一致的！</p><p>浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值+♾️，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同——整数的表示虽然智能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。</p><p>通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了解这种属性是非常重要的。后面我们会讲到，大量计算机的安全漏洞都是由于计算机算数运算的微妙细节引发的。在早期，当人们碰巧触发了程序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们的程序如何工作，以及如何被迫产生不良的行为。</p><p>计算机用几种不同的二进制表示形式来编码数值。通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。</p><h4 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h4><p>大多数计算机使用8位的块，或者<strong>字节</strong>（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存</strong>（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的<strong>地址</strong>（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器（DRAM）、内存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。</p><p>接下来，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的<strong>程序对象</strong>（program object），即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。</p><blockquote><p>指针是C语言的一个重要特性。它提供了引用数据结构（包括数组）的元素机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。</p></blockquote><h5 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h5><p>一个字节由8位组成。在二进制表示法中，它的值域是0000 0000 ～ 1111 1111。如果看成十进制整数，它的值域就是 0～255。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以16为基数，或者叫做<strong>十六进制</strong>（hexadecimal）数，来表示位模式。十六进制（简写为’hex’）使用数字 0～9 以及字符 A～F 来表示16个可能的值。</p><p>在C语言中，以 0x 或 Ox 开头的数字常量被认为是十六进制的值。字符 A～F 既可以是大写，也可以是小写，甚至可以是大小写混合。</p><p>编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以执行一个十六进制数字的转换——即四位表示一位。一个简单的窍门是，记住十六进制数字A、C和F相应的十进制值。而对于把十六进制值B、D和E转换成十进制值，则可以通过计算它们与前三个值的相对关系来完成。</p><blockquote><p>较大数值的十进制和十六进制之间的转换，最好是让计算机或者计算器来完成。</p></blockquote><h5 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h5><p>每台计算机都有一个<strong>字长</strong>（word size），指明指针数据的<strong>标称大小</strong>（normal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长位 w 位的机器而言，虚拟地址的范围为 0 ~ $2^w -1$，程序最多访问$2^w$个字节。</p><p>最近这些年，出现了大规模的从32位字长机器到64位字长机器到迁移。这种情况首先出现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在智能手机的处理器上。32位字长限制虚拟地址空间为4千兆字节（写作4GB），也就是说，刚刚超过$4 \times 10^9$字节。扩展到64位字长使得虚拟地址空间为16EB，大约是$1.84 \times 10^{19}$​字节。</p><p>大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。我们将程序称为“32位程序”或“64位程序”时，区别在于该程序时如何编译的，而不是其运行的机器类型。</p><p>计算机和编译器支持多种不同方式编码的数字格式，如不同长度的整数和浮点数。比如，许多机器都有处理单个字节的指令，也有处理表示为2字节、4字节或者8字节整数的指令，还有些指令支持表示为4字节和8字节的浮点数。</p><p>C语言支持整数和浮点数的多种数据格式。有些数据类型的确切字节数依赖于程序是如何被编译的。整数或者为有符号的，即可以表示负数、零和正数；或者为无符号的，即只能表示非负数。C的数据类型char 表示一个单独的字节。尽管”char”是由于它被用来存储文本串中的单个字符这一事实而得名，但它也能被用来存储整数值。数据类型 short、int 和 long 可以提供各种数据大小。即使是为64位系统编译，数据类型 int 通常也只有4个字节。数据类型 long 一般在32位程序中为4字节，在64位程序中则为8字节。</p><p>为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 int32_t 和 int64_t，它们分别为4个字节和8个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。</p><p>大部分数据类型都编码为有符号数值，除非有前缀关键字 unsigned 或对确定大小的数据类型使用了特定的无符号声明。数据类型 char 是一个例外。尽管大多数编译器和机器将它们视为有符号数，但C标准不保证这一点。相反，正如方括号指示的那样，程序员应该用有符号字符的声明来保证其为一个字节的有符号数值。不过，在很多情况下，程序行为对数据类型 char 是有符号的还是无符号的并不敏感。</p><p>程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C语言标准对不同数据类型的数字范围设置了下界，但是却没有上界。</p><h5 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h5><p>对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</p><p>排列表示一个对象的字节有两个通用的规则。考虑一个 w 位的整数，其位表示为[x<sub>w-1</sub>, x<sub>w-2</sub>, …, x<sub>1</sub>, x<sub>0</sub>]，其中x<sub>w-1</sub>是最高有效位，而x<sub>0</sub>是最低有效位。假设 w 是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含位[x<sub>w-1</sub>, x<sub>w-2</sub>, … , x<sub>w-8</sub>]，而最低有效字节包含位[x<sub>7</sub>, x<sub>6</sub>, … , x<sub>0</sub>]，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则是按照从最高有效字节到最低有效字节到顺序存储。前一种规则——最低有效字节在最前面的方式，成为<strong>小端法</strong>(little endian)。后一种规则——最高有效字节在最前面的方式，称为<strong>大端法</strong>(big endian)。</p><p>许多比较新的微处理器是<strong>双端法</strong>(big-endian)，也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是：一旦选择了特定操作系统，那么字节顺序也就固定下来了。</p><p>对于大多数应用程序猿来说，其机器所使用的字节顺序是完全不可见的。无论是哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接受程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。</p><p>第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在检查机器级程序时。</p><p>字节顺序变得重要的第三种情况是编写规避正常的类型系统的程序时。在C语言中，可以通过使用<strong>强制类型转换</strong>(cast)或<strong>联合</strong>(union)来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用的，甚至是必须的。</p><h5 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h5><p>C语言中字符串被编码为一个以 null (其值为 0 )的字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符串。在使用ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因此，文本数据比二进制数据具有更强的平台独立性。</p><blockquote><p>基本编码，称为 Unicode 的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占4个字节。不过，可以有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8 表示将每个字符编码为一个字节序列，这样标准 ASCII 字符还是使用和它们在 ASCII 中一样的单字节编码，这也就意味着所有的 ASCII 字节序列用ASCII码表示和用 UTF-8 表示是一样的。</p></blockquote><h5 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h5><p>当我们在机器上编译，生成字节表示的机器代码，我们会发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p><p>计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。</p><h5 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h5><p>二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学知识体系。布尔注意到通过将逻辑值TRUE(真)和FALSE(假)编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。</p><p>布尔运算 ～ 对应于逻辑运算 NOT，在命题逻辑中用符号¬表示。也就是说，当P不是真的时候，我们就说¬P是真的，反之亦然。相应地，当 P 等于0时， ～P 等于1，反之亦然。布尔运算 &amp; 对应于逻辑运算 AND，在命题逻辑中用符号∧表示。当 P 和 Q都为真时，我们说 P ∧ Q 为真。相应地，当只有 p =1 且 q = 1时，p &amp; q 才等于1。布尔运算 | 对应于逻辑运算 OR ，在命题逻辑中用符号 ∨ 表示。当 P 或者 Q 为真时，我们说 P ∨ Q 成立。相应地，当 p = 1 或者 q = 1 时， p | q 等于1。布尔运算 ^ 对应于逻辑运算异或，在命题逻辑中用符号⊕表示。当 P 或者 Q为真但不同时为真时，我们说 P⊕Q 成立。相应地，当 p=1 且 q=0，或者 p=0 且 q=1时，p^q 等于1。</p><p>我们可以将上述4个布尔运算扩展到位向量的运算，位向量就是固定长度为w、由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。</p><blockquote><p>对于任意整数w&gt;0，长度为w的位向量上的布尔运算 |、&amp; 和~ 形成了一个布尔代数。最简单的情况是 w=1时，只有2个元素；但是对于更普遍的情况，有2<sup>w</sup> 个长度为w的位向量。布尔代数和整数算术运算有很多相似之处。 当考虑长度为 w 的位向量上的 ^、 &amp; 和 ~ 运算时，会得到一种不同的数学形式，我们称为<strong>布尔环</strong>(Boolean ring)。布尔环与整数运算有很多相同的属性。</p></blockquote><p>位向量一个很有用的应用就是表示有限集合。在大量实际应用中，我们都能看到用位向量来对集合编码。</p><h5 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h5><p>C语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使用的那些符号就是C语言所使用的：| 就是 OR（或），&amp; 就是 AND（与），～ 就是 NOT（取反），而 ^ 就是 EXCLUSIVE-OR（异或）。这些运算能运行到任何“整型”的数据类型上。确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转回十六进制。</p><p>位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。</p><h5 id="2-1-8-C-语言中的逻辑运算"><a href="#2-1-8-C-语言中的逻辑运算" class="headerlink" title="2.1.8 C 语言中的逻辑运算"></a>2.1.8 C 语言中的逻辑运算</h5><p>C 语言还提供了一组逻辑运算符 ||、&amp;&amp; 和 !，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。</p><p>按位运算只有在特殊情况下，也就是参数被限制为 0 或者 1 时，才和与其他对应的逻辑运算有相同的行为。</p><p>逻辑运算符 &amp;&amp; 和 || 与它们对应的位级运算 &amp; 和 | 之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。</p><h5 id="2-1-9-C-语言中的移位运算"><a href="#2-1-9-C-语言中的移位运算" class="headerlink" title="2.1.9 C 语言中的移位运算"></a>2.1.9 C 语言中的移位运算</h5><p>C 语言还提供了一组<strong>移位</strong>运算。向左或者向右移动位模式。对于一个位表示为 [x<sub>w-1</sub>, x<sub>w-2</sub>, …, x<sub>0</sub>] 的操作数 x，C 表达式 x&lt;&lt;k 会生成一个值，其位表示为 [x<sub>w-k-1</sub>, x<sub>w-k-2</sub>, …, x<sub>w-1</sub>, 0, …, 0]。也就是说，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个0。移位量应该是一个 0~w-1 之间的值。移位运算是从左至右可结合的，所以 x&lt;&lt;j&lt;&lt;k 等价于 (x&lt;&lt;j)&lt;&lt;k。</p><p>有一个相应的右移运算 x&gt;&gt;k，但是它的行为有点微妙。一般而言，机器支持两种形式的右移：<strong>逻辑右移</strong>和<strong>算术右移</strong>。逻辑右移在最左端补k个0，得到的结果是[0, …, 0, x<sub>w-1</sub>, x<sub>w-2</sub>, …, x<sub>k</sub>]。算术右移是在左端补 k 个最高有效位的值，得到的结果是[x<sub>w-1</sub>, …, x<sub>w-1</sub>, x<sub>w-1</sub>, x<sub>w-2</sub>, …, x<sub>k</sub>]。这种做法看上去可能有点奇特，但是我们会发现它对有符号整数数据的运算非常有用。</p><p>C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，机会所有的编译器/机器组合都对有符号数使用算数右移，且许多程序猿也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。</p><h4 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h4><p>用位来编码整数有两种不同的方式：一种只能表示非负数，而另一种能够表示负数、零和正数。后面我们将会看到它们在数学属性和机器级实现方面密切相关。我们还会研究扩展或者收缩一个已编码整数以适应不同长度表示的效果。</p><h5 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h5><p>C 云烟支持多种<strong>整形</strong>数据类型——表示有限范围的整数。每种类型都能用关键字来指定大小，这些关键字包括 char、short、long，同时还可以指示被表示的数字是非负数（声明为 unsigned），或者可能是负数（默认）。</p><p>为这些不同的大小分配的字节数根据程序编译为 32 位还是 64 位而有所不同。根据字节分配，不同的大小所能表示的值的范围是不同的。这里给出来的唯一一个与机器相关的取值范围是大小指示符 long 的。大多数 64 位机器使用 8 个字节的表示，比 32 位机器上使用的 4 个字节的表示的取值范围大很多。</p><h5 id="2-2-2-无符号数的编码"><a href="#2-2-2-无符号数的编码" class="headerlink" title="2.2.2 无符号数的编码"></a>2.2.2 无符号数的编码</h5><p>无符号数的二进制表示有一个很重要的属性，也就是每个介于 0~2<sup>w</sup> -1之间的数都有唯一一个 w 位的值编码。即无符号数编码的唯一性。 函数B2U<sub>w</sub> 是一个双射。</p><h5 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h5></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>TonyShng</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://raintwo.wang/2021/07/30/%E3%80%90System%E3%80%91Chapter2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%A4%84%E7%90%86/" title="【System】Chapter2:信息的表示及处理">https://raintwo.wang/2021/07/30/【System】Chapter2-信息的表示及处理/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/System/" rel="tag"><i class="fa fa-tag"></i> System</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/07/28/%E3%80%90System%E3%80%91Chapter1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/" rel="prev" title="【System】Chapter1:计算机系统漫游"><i class="fa fa-chevron-left"></i> 【System】Chapter1:计算机系统漫游</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC80NTQxNi8yMTkyOA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">12122121212</a></div><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">TonyShng</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });</script><script>NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "2021/07/30/【System】Chapter2-信息的表示及处理/"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script></body></html>